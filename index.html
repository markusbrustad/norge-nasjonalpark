<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Norway National Parks — Two SVGs (Leader-Line Pairing)</title>
  <style>
    :root{
      --bg:#f8f9fb;
      --park:#b0b7c3;        /* default gray */
      --park-active:#2bb673; /* green when selected */
      --label:#6b7280;       /* default label gray */
      --label-active:#1f2937;/* darker when active */
      --stroke:#9aa4b2;      /* park stroke */
    }
    html, body {height:100%;}
    body { margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; background:var(--bg); color:#0f172a; display:grid; grid-template-rows:auto 1fr; }
    header { padding:12px 16px; border-bottom:1px solid #e5e7eb; background:#fff; display:flex; gap:12px; align-items:center; }
    header h1 { font-size:clamp(16px,2.2vw,20px); margin:0; font-weight:650; }
    .toolbar { margin-left:auto; display:flex; gap:8px; }
    button{ appearance:none; border:1px solid #e5e7eb; background:#fff; padding:8px 10px; border-radius:10px; cursor:pointer }
    .map-wrap{ position:relative; overflow:hidden; background:#e9eef5; }
    svg{ display:block; width:100%; height:100%; }

    /* Basemap non-interactive so clicks go to parks */
    #basemap, #basemap * { pointer-events:none; }

    /* Park shapes */
    .park { fill: var(--park); stroke: var(--stroke); stroke-width: 0.7; cursor:pointer; transition: fill .15s ease; }
    .park.active { fill: var(--park-active); }

    /* Labels */
    .label { font-size: 10px; fill: var(--label); pointer-events: none; transition: font-weight .15s ease, fill .15s ease; }
    .label.active { font-weight: 700; fill: var(--label-active); }

    @media (max-width: 480px){ .label{ font-size: 9px; } }
    .park:focus { outline: none; filter: drop-shadow(0 0 0.6px #1118); }
  </style>
</head>
<body>
  <header>
    <h1>Norway National Parks — External SVG (Leader-Line Pairing)</h1>
    <div class="toolbar">
      <button id="resetBtn" title="Reset zoom">Reset</button>
    </div>
  </header>
  <div class="map-wrap">
    <!-- Put index.html, basemap.svg, national_parks_lable.svg in the SAME folder -->
    <svg id="map" viewBox="0 0 1000 1600" role="img" aria-label="Interactive map of Norway with national parks (two external SVGs)">
      <g id="viewport">
        <g id="basemap"></g>
        <g id="parksAndLabels"></g>
      </g>
    </svg>
  </div>

  <script src="https://unpkg.com/d3@7/dist/d3.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script>
  (async function(){
    const svg = d3.select('#map');
    const viewport = d3.select('#viewport');
    const gBase = d3.select('#basemap');
    const gPL = d3.select('#parksAndLabels');
    const resetBtn = document.getElementById('resetBtn');

    async function loadSVG(url, target){
      const resp = await fetch(url);
      if(!resp.ok) throw new Error(url + ' ' + resp.status);
      const text = await resp.text();
      const doc = new DOMParser().parseFromString(text, 'image/svg+xml');
      const srcSvg = doc.documentElement; // <svg>
      const frag = document.createDocumentFragment();
      Array.from(srcSvg.childNodes).forEach(n => frag.appendChild(document.importNode(n, true)));
      target.node().appendChild(frag);
      const vb = srcSvg.getAttribute('viewBox');
      const w = srcSvg.getAttribute('width');
      const h = srcSvg.getAttribute('height');
      return {vb, w, h};
    }

    function parseVB(vb){ if(!vb) return null; const a = vb.trim().split(/\s+/).map(Number); return {x:a[0], y:a[1], w:a[2], h:a[3]}; }

    let baseInfo, plInfo;
    try{
      baseInfo = await loadSVG('basemap.svg', gBase);
      plInfo   = await loadSVG('national_parks_lable.svg', gPL);
    } catch(e){
      console.error(e);
      alert('Could not load basemap.svg or national_parks_lable.svg. Use a local server (python -m http.server).');
      return;
    }

    const vbBase = parseVB(baseInfo.vb);
    const vbPL   = parseVB(plInfo.vb);

    // Root viewBox follows basemap
    if(vbBase){ svg.attr('viewBox', `${vbBase.x} ${vbBase.y} ${vbBase.w} ${vbBase.h}`); }

    // Align parks/labels group to basemap
    if(vbBase && vbPL){
      const sx = vbBase.w / vbPL.w;
      const sy = vbBase.h / vbPL.h;
      const tx = vbBase.x - vbPL.x * sx;
      const ty = vbBase.y - vbPL.y * sy;
      gPL.attr('transform', `translate(${tx},${ty}) scale(${sx},${sy})`);
    }

    // --- CLEANUP ---
    // Neutralize any background rectangles so they don't cover the map
    gPL.selectAll('rect').attr('fill','none').attr('pointer-events','none');

    // Parks: only PATH + POLYGON
    const parksSel = gPL.selectAll('path, polygon');
    parksSel.each(function(){ this.removeAttribute('fill'); this.removeAttribute('stroke'); });
    parksSel.classed('park', true).attr('tabindex', 0).attr('role','button');

    // Labels: any <text>
    const labelsSel  = gPL.selectAll('text').classed('label', true).attr('pointer-events','none');
    labelsSel.each(function(){ this.parentNode.appendChild(this); }); // bring to front
    labelsSel.each(function(_, i){ if(!this.id) this.id = 'label-' + (i+1); });

    const svgEl = svg.node();
    const toScreen = (el, pt) => {
      const p = svgEl.createSVGPoint(); p.x = pt.x; p.y = pt.y; const ctm = el.getCTM(); return ctm ? p.matrixTransform(ctm) : p; };
    const centerInScreen = (el) => { const bb = el.getBBox(); return toScreen(el, {x: bb.x + bb.width/2, y: bb.y + bb.height/2}); };

    const labelNodes = labelsSel.nodes().map(n => {
      const bb = n.getBBox();
      const center = toScreen(n, {x: bb.x + bb.width/2, y: bb.y + bb.height/2});
      return { id: n.id, node: n, screen: center };
    });

    // --- LEADER LINE PAIRING ---
    // Leaders can be <line>, <polyline>, or stroke-only <path> that are NOT park polygons.
    const parkNodeSet = new Set(parksSel.nodes());
    const leaderCand = gPL.selectAll('line, polyline, path').filter(function(){ return !parkNodeSet.has(this); });

    function getEndpointsLocal(el){
      const tag = el.tagName.toLowerCase();
      if(tag === 'line'){
        const x1 = +el.getAttribute('x1') || 0, y1 = +el.getAttribute('y1') || 0;
        const x2 = +el.getAttribute('x2') || 0, y2 = +el.getAttribute('y2') || 0;
        return [{x:x1,y:y1},{x:x2,y:y2}];
      }
      if(tag === 'polyline'){
        const pts = (el.getAttribute('points') || '').trim().split(/\s+/).map(p=>p.split(',').map(Number)).filter(a=>a.length===2);
        if(pts.length >= 2){ return [{x:pts[0][0], y:pts[0][1]}, {x:pts[pts.length-1][0], y:pts[pts.length-1][1]}]; }
        return null;
      }
      if(tag === 'path'){
        // Treat stroke-only paths as leaders (skip if they have fill other than none)
        const fill = (el.getAttribute('fill') || '').toLowerCase();
        if(fill && fill !== 'none') return null;
        try{
          const L = el.getTotalLength();
          const p0 = el.getPointAtLength(0); const p1 = el.getPointAtLength(Math.max(0, L));
          return [{x:p0.x, y:p0.y}, {x:p1.x, y:p1.y}];
        }catch(e){ return null; }
      }
      return null;
    }

    const leaders = [];
    leaderCand.nodes().forEach(el => {
      const ends = getEndpointsLocal(el);
      if(!ends) return;
      const endsScreen = ends.map(pt => toScreen(el, pt));
      // Find nearest label to either endpoint
      let bestLabel = null, bestD = Infinity, bestEndIdx = 0;
      for(const L of labelNodes){
        for(let i=0;i<endsScreen.length;i++){
          const dx = L.screen.x - endsScreen[i].x; const dy = L.screen.y - endsScreen[i].y; const d2 = dx*dx + dy*dy;
          if(d2 < bestD){ bestD = d2; bestLabel = L; bestEndIdx = i; }
        }
      }
      if(bestLabel){
        leaders.push({ el, labelId: bestLabel.id, labelEnd: endsScreen[bestEndIdx], parkEnd: endsScreen[bestEndIdx ? 0 : 1] });
      }
    });

    // If no leaders found, we'll fall back later

    // Pair each park to the nearest leader's park-end, then inherit that leader's label
    parksSel.each(function(){
      const el = this;
      // Respect pre-linked shapes
      if(el.hasAttribute('data-label-id')) return;
      const pc = centerInScreen(el);
      let best = null, bestD = Infinity;
      for(const L of leaders){
        const dx = L.parkEnd.x - pc.x; const dy = L.parkEnd.y - pc.y; const d2 = dx*dx + dy*dy;
        if(d2 < bestD){ bestD = d2; best = L; }
      }
      if(best){ el.setAttribute('data-label-id', best.labelId); }
    });

    // --- FALLBACKS (if some parks still have no label) ---
    function labelInsideShape(labelPt, shapeEl){
      if(typeof shapeEl.isPointInFill !== 'function') return false;
      const pt = svgEl.createSVGPoint(); pt.x = labelPt.x; pt.y = labelPt.y;
      const inv = shapeEl.getCTM() && shapeEl.getCTM().inverse(); if(!inv) return false;
      const local = pt.matrixTransform(inv);
      try{ return shapeEl.isPointInFill(local); }catch(e){ return false; }
    }

    parksSel.each(function(){
      const el = this;
      if(el.hasAttribute('data-label-id')) return; // already paired
      // 1) Name match (id/title/data-name vs label text)
      const titleEl = el.querySelector && el.querySelector('title');
      const rawName = (el.getAttribute('data-name') || (titleEl && titleEl.textContent) || el.id || '').trim();
      const norm = s => (s||'').toLowerCase().normalize('NFD').replace(/\p{Diacritic}/gu,'').replace(/[^a-z0-9]+/g,'-').replace(/(^-|-$)/g,'');
      const key = norm(rawName);
      if(key){
        const match = labelNodes.find(L => norm(L.node.textContent) === key);
        if(match){ el.setAttribute('data-label-id', match.id); return; }
      }
      // 2) Inside test
      const inside = labelNodes.find(L => labelInsideShape(L.screen, el));
      if(inside){ el.setAttribute('data-label-id', inside.id); return; }
      // 3) Nearest
      const pc = centerInScreen(el);
      let best = null, bestD = Infinity;
      for(const L of labelNodes){ const dx = L.screen.x - pc.x, dy = L.screen.y - pc.y; const d2 = dx*dx + dy*dy; if(d2 < bestD){ bestD = d2; best = L; } }
      if(best){ el.setAttribute('data-label-id', best.id); }
    });

    // Interaction
    function togglePark(el){
      const park = d3.select(el);
      const label = d3.select('#' + park.attr('data-label-id'));
      const isActive = park.classed('active');
      park.classed('active', !isActive);
      label.classed('active', !isActive);
    }

    parksSel.on('click', (event)=> togglePark(event.currentTarget));
    parksSel.on('keydown', (event)=>{ if(event.key === 'Enter' || event.key === ' '){ event.preventDefault(); togglePark(event.currentTarget); } });

    // Zoom/pan (1x–4x)
    const zoom = d3.zoom().scaleExtent([1,4]).on('zoom', (event)=>{ viewport.attr('transform', event.transform); });
    svg.call(zoom);

    // Reset
    resetBtn.addEventListener('click', ()=>{
      svg.transition().duration(250).call(zoom.transform, d3.zoomIdentity);
      d3.selectAll('.park.active').classed('active', false);
      d3.selectAll('text.label.active').classed('active', false);
    });

    // Double-click to zoom to a park
    parksSel.on('dblclick', (event)=>{
      event.preventDefault();
      const node = event.currentTarget; const bbox = node.getBBox();
      const {width, height} = svg.node().getBoundingClientRect();
      const scale = Math.min(4, Math.max(1, Math.min(width / (bbox.width * 1.5), height / (bbox.height * 1.5))));
      const tx = width/2 - scale * (bbox.x + bbox.width/2);
      const ty = height/2 - scale * (bbox.y + bbox.height/2);
      const t = d3.zoomIdentity.translate(tx, ty).scale(scale);
      svg.transition().duration(350).call(zoom.transform, t);
    });
  })();
  </script>
</body>
</html>
